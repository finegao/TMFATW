---
layout: post
title:  "算法"
date:   2017-08-23
tags: [算法]
---
### Algorithm

DSA: Data Structure + Algorithm

#### 有穷性

算法必须有穷的，否则是个死循环。

例子：hailstone sequence 冰雹序列

#### 健壮

健壮指的是程序不知能够正确的输入，而且还能对错误的输入进行反馈

#### 效率

最重要的是效率

#### 性能测度

性能测度是测量效率的

> To measure is to know,
> If you can not measure it,
> you can not improve it
> \- Lord Kelvin

测度： 时间成本 + 空间成本

#### 图灵机

[图灵机 wiki](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA)

图灵机模拟自然计算的过程

#### RAM

RAM：Random Access Machine

图灵机和RAM模型都是性能测度工具测度

#### 大O记号

这是一种测度性能的渐进分析，就是在问题规模足够大时，计算成本如何增长。所以我们主要是看它的变化趋势，也就是斜率，随着 n 的增加，时间的变化剧烈程度。

T(n) = O(f(n))

常系数可忽略：O(f(n)) = O(c * f(n))  
低次项可忽略：O(n^a + n^b) = O(n^a) a > b

有些算法在 n 小的时候时间成本反而比 n 大的时候要高

#### 高效解

常数方程 O(1)，如果有算法可以达到 O(1)，那么它是最高效的。

对于没有 循环/分支/递归 的算法可以认为是 O(1) 复杂度。

对数方程 O(log n) 底数可以忽略，这类也是高效的，因为会接近常数方程

#### 有效解

多项式复杂度 O(n^k)，可以忽略低次项，最高次项的常数也可以忽略

线性复杂度 O(n)

#### 难解

指数复杂度 O(2^n) 往往认为是不可取的，但是算法的指数复杂度解往往比较容易得到，而多项式反而不容易得到。

#### 复杂度分析

#### 气泡排序

#### 递归

递归的思想，求解 n 的问题，那么要先求解 n-1 的问题

`T(n) = T(n-1) + O(1)` 然后添加边界条件 什么时候结束递归

#### 二分递归

把问题分成两个部分，在分别递归求解两个子问题

#### 动态规划

- make it work
- make it right
- make it fast

前两步可以用 **递归** 解决 最后一步可以用 **迭代** 解决

动态规划 可以理解为利用递归解决问题之后 在转化为迭代的形式

递归的复杂度太高，主要是因为重复利用了已经之前完成的递归项

递归的思想，总是从反向考虑问题，把问题缩减为 n-1 的形式，然后不断的迭代。但是递归产生的问题在于重复使用已经解决的项，这时需要正向考虑或者制表。

#### 接口与实现

Abstract Data Type / Data structure

#### 向量

向量本质上是一个数组的推广和泛化形式

向量的接口 也就是向量的一系列封装好的操作

静态空间分布/动态空间分布

#### 无序向量

#### 二分查找

#### fibonacci 查找

#### 插值查找

元素符合某个规律，那么我们按照概率大体定位元素位置，更加快速的找到目标

#### 气泡排序

气泡排序存在可以改进的地方，比如判断之前的排序是否有过 逆序 没有的话这个排序其实已经完成了

#### 归并排序

把向量分解为几个小的向量，然后对每一个小向量排序，完成后在合并每一个向量


#### 列表 list

列表与向量一样都是线性结构

列表采用动态储存策略，其中的元素成为节点 node， 各个节点通过指针或者引用链接，只在逻辑上构成一个序列， 物理位置是无序的。

链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。

使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

链表只能根据指针找到相邻的元素，而不能像数组一样选取任意坐标操作。

#### 选择排序

找到极值最大或者最小，进行排序

选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

#### 插入排序

插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：
从第一个元素开始，该元素可以认为已经被排序
取出下一个元素，在已经排序的元素序列中从后向前扫描
如果该元素（已排序）大于新元素，将该元素移到下一位置
重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
将新元素插入到该位置后
重复步骤2~5
如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。

#### 逆序对

坐标小的元素比坐标大的元素包含的值大，它常用于量度排列或序列的已排序程度

#### 栈与队列

他们是都是线性序列的特例

堆栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的数据结构，其特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。堆叠的另外一个相对的操作方式称为伫列。

由于堆叠数据结构只允许在一端进行操作，因而按照 **后进先出**（LIFO, Last In First Out）的原理运作。

堆栈可以用链表和数组两种方式实现，一般为一个堆栈预先分配一个大小固定且较合适的空间并非难事，所以较流行的做法是Stack结构下含一个数组。如果空间实在紧张，也可用链表实现，且去掉表头。这里的例程是以数组实现的。

栈的应用场景

- 逆序输出 更改进制
- 递归嵌套 括号匹配
- 延迟缓冲
- 栈式计算 逆波兰表示法

逆波兰表示法是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。

逆波兰结构由弗里德里希·鲍尔（Friedrich L. Bauer）和艾兹格·迪科斯彻在1960年代早期提议用于表达式求值，以利用堆栈结构减少计算机内存访问。

逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 \* 5”与“（3 - 4）\*5”不相同，但后缀记法中前者写做“3 4 5 \* -”，无歧义地表示“3 (4 5 \*) -”；后者写做“3 4 - 5 \*”。

逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。

#### 队列

队列与栈的结构对称，在树和图中很广泛的应用，它是先进先出。

队列，又称为伫列（queue），是 **先进先出**（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。

队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。

#### 树

之前的都是 向量 和 列表 的数据结构

树可以理解为列表的列表，或者二维的列表

在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n>0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：

- 每个节点有零个或多个子节点；
- 没有父节点的节点称为根节点；
- 每一个非根节点有且只有一个父节点；
- 除了根节点外，每个子节点可以分为多个不相交的子树；

- 节点的 **度**：一个节点含有的子树的个数称为该节点的度；
- 树的度：一棵树中，最大的节点的度称为树的度；
- 叶节点或终端节点：度为零的节点；
- 非终端节点或分支节点：度不为零的节点；
- 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；
- 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；
- 兄弟节点：具有相同父节点的节点互称为兄弟节点；
- 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
- 深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；
- 高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；
- 堂兄弟节点：父节点在同一层的节点互为堂兄弟；
- 节点的祖先：从根到该节点所经分支上的所有节点；
- 子孙：以某节点为根的子树中任一节点都称为该节点的子孙。
- 森林：由m（m>=0）棵互不相交的树的集合称为森林；

树的种类
- 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树；
- 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树；
  - 二叉树：每个节点最多含有两个子树的树称为二叉树；
    - 完全二叉树：对于一颗二叉树，假设其深度为d（d>1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树；
      - 满二叉树：所有叶节点都在最底层的完全二叉树；
    - 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；
    - 排序二叉树(二叉查找树（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)；
  - 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；
  - B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多余两个子树。


树中的节点比边多一个

路径，树的节点之间的构成的通路，亦是边的数量
